# my_first_mips
in this simple project we will create a  POC of a MIP CPU.

## MIPS CPU - RTL \\the module design.
simple single cycle mips cpu - using a fetch-decode-execute-memory-writeback structure.

## MIPS CPU - verification \\the TB design.
will provide reset, clk, 
The TB will simply use XMR (xross module reference) to connect the CPU to the memory and the CPU to the instruction memory.
it will print the values of the registers and the memory so we can see and check the results of the program.

## MIPS CPU - test
using python we will create a sw "assembler" that will convert the assembly code to machine code. and will create a memory file that will be used by the TB.

### to sum up:  
|file name | description|
|----------|----------|
| rtl | mips module: the actual design files of the MIPS CPU |
| verif | holds testbenches and focuses on testing individual components (like the ALU, register file, and control unit) |
| app | (Application) Stores MIPS assembly programs for application-level testing (confirms that the entire CPU functions correctly as an integrated system) |


### to sum all files up:  
|file name | description|
|----------|----------|
| rtl/mips.sv | MIPS module: the actual design files of the MIPS CPU |
| verif/mips_tb.sv | Testbench for the MIPS CPU: provides reset, clock, and loads the instruction memory for simulation |
| verif/alive.asm | Assembly code for testing the MIPS CPU |
| app/asm_compiler.py | Python script to convert assembly code to machine code |
| app/machine2sv_sim.py | Python script to convert machine code to a SystemVerilog-readable memory initialization file |
| output_app/alive.sv | Generated machine code from the assembly code in `verif/alive.asm` |
| output_app/load_mem.sv | SystemVerilog memory initialization file generated from the machine code |
| test | Assembly code for simple ADD and SUB tests for the MIPS CPU |
| transcript | Simulation transcript showing the results of the testbench execution |
| .gitignore | Specifies files and directories to be ignored by Git |
| syntax_breakdown.md | Explanation of the syntax and macros used in the RTL design |
| vsim.wlf | Waveform database file generated by the simulator |



## Project Steps

1. **Create the MIPS module**:
   - Implement the MIPS CPU in `rtl/mips.sv`. meaing the fetch-decode-execute-memory-writeback structure.


2. **Create the testbench**:
   - Develop the testbench in `verif/mips_tb.sv` to provide reset, clock, and load the instruction memory for simulation.
   - The testbench will instantiate the MIPS CPU module and provide necessary signals to simulate its operation.
   - It will also include mechanisms to monitor and verify the outputs of the CPU.


3. **Add assembly code**:
   - Write the assembly code in `verif/alive.asm` for testing the MIPS CPU.
   - This assembly code will include various instructions to test different functionalities of the CPU.


4. **Create the assembler**:
   - Develop `app/asm_compiler.py` to compile the assembly code into machine code, by translating the assembly instructions into binary machine code. and saving the output in `output_app/alive.sv`.  

   - This script reads the assembly code from `verif/alive.asm` and translates it into binary machine code that the MIPS CPU can execute.

    in order to get an output we will run the following command: `python3 app/asm_compiler.py verif/alive.asm output_app/alive.sv`


5. **Generate memory initialization file**:
   - Use `app/machine2sv_sim.py` to convert the machine code to a SystemVerilog-readable memory initialization file. This file will be used to initialize the instruction memory in the testbench.
   - The output will be saved in `output_app/load_mem.sv`.
   - In order to get an output, run the following command:
     ```sh
     python3 app/machine2sv_sim.py output_app/alive.sv output_app/load_mem.sv
     ```
   - This script reads the machine code from [alive.sv](http://_vscodecontentref_/1) and writes the memory initialization file to [load_mem.sv](http://_vscodecontentref_/2).
   - The generated `load_mem.sv` file will be included in the testbench to load the instructions into the instruction memory for simulation.


6. **Run simulations**:
   - Execute the testbench to simulate the MIPS CPU with the provided assembly code and verify the results.
   - Use a simulation tool (e.g., ModelSim, VCS) to run the testbench and observe the behavior of the MIPS CPU.
   - Ensure that the CPU correctly executes the instructions and produces the expected outputs.


7. **Analyze results**:
   - Check the simulation transcript and waveform to ensure the MIPS CPU operates correctly.
   - Use waveform viewers and log files to inspect the internal signals and outputs of the CPU during simulation.
   - Verify that the CPU performs the correct operations and updates the registers and memory as expected.


8. **Iterate and improve**:
   - Refine the MIPS module, testbench, and assembly code based on the simulation results to improve functionality and performance.
   - Identify and fix any issues or bugs in the design.
   - Optimize the CPU implementation for better performance and resource utilization.
   - Add more test cases and assembly programs to thoroughly test the CPU under different scenarios.


